lda <getal>
ldb <getal>


add     #result -> RegA
sub 
mul
div

push    #push result to stack
pop     #pop stack to regA
call <adres>    #call an subroutine
ret             #Return from subroutine

sto   <adres>   #stores result to memory
sta   <adres>
stb   <adres>
lma   <adres>   #loads mem adres to regA
lmb   <adres>   #loads mem adres to regB

idx                 #regB to IX
stx <adres> + IX    #store result
lxa <adres> + IX
lxb <adres> + IX

inc (a | b | x)
dec (a | b | x)

jmp <adres>
test (eq | gt | z)  #result = 0 whem true, else result != 0

jmpt <adres>    #jump to adres when zero bit is true (when last result = 0)
jmpf <adres>    #jump to adres when zero bit is false

skpt            # pc = pc + 1 when zero bit is true (when last result = 0)

out <device number>     #result to buffer
in  <device number>     #Input buffer to regA

halt


